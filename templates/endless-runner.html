<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless Runner Game</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <canvas id="game-canvas" width="800" height="400"></canvas>
    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        const player = {
            x: 100,
            y: canvas.height - 50,
            width: 50,
            height: 50,
            velocityY: 0,
            jumping: false,
        };

        const obstacles = [];

        let score = 0;
        let gameOver = false;
        let obstacleSpawnInterval = 2000; // Initial obstacle spawn interval

        // Load player images
        const playerImage1 = new Image();
        playerImage1.src = 'https://lh3.googleusercontent.com/d/1bSLZ68ODsCZfCVr2KupMpMN3nEsyL71N';

        const playerImage2 = new Image();
        playerImage2.src = 'https://lh3.googleusercontent.com/d/1V4tHGAsRyh91CKB_5EL8IqpzQASGyuHf';

        let currentImage = playerImage1;

        // Load obstacle images (placeholders)
        const rockImage = new Image();
        rockImage.src = 'https://lh3.googleusercontent.com/d/1hQpKpPzt3jM7yVFt55Qn-UTZz8yFgPWX';

        const treeImage = new Image();
        treeImage.src = 'https://lh3.googleusercontent.com/d/16N2krlshWqIkYFa5LldNmxCuQcwAfUZO';

        const birdImage = new Image();
        birdImage.src = 'https://via.placeholder.com/70x20.png';

        function drawPlayer() {
            ctx.clearRect(player.x, player.y, player.width, player.height);
            ctx.drawImage(currentImage, player.x, player.y, player.width, player.height);
        }

        function animatePlayer() {
            currentImage = (currentImage === playerImage1) ? playerImage2 : playerImage1;
            setTimeout(animatePlayer, 100); // Switch image every 100ms (adjust as needed for faster animation)
        }

        function drawObstacles() {
            for (const obstacle of obstacles) {
                // Draw obstacle based on its type (rock, tree, or bird)
                if (obstacle.type === 'rock') {
                    ctx.drawImage(rockImage, obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                } else if (obstacle.type === 'tree') {
                    ctx.drawImage(treeImage, obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                } else if (obstacle.type === 'bird') {
                    ctx.drawImage(birdImage, obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                }
            }
        }

        function updateObstacleSpeed() {
            if (score >= 100 && obstacleSpawnInterval !== 1500) {
                obstacleSpawnInterval = 1500; // Update the obstacle spawn interval to a faster value at score +100
            } else if (score >= 200 && obstacleSpawnInterval !== 1000) {
                obstacleSpawnInterval = 1000; // Update the obstacle spawn interval to an even faster value at score +200
            }
        }

        function update() {
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameOver) {
                // Display "Game Over" message
                ctx.font = '40px Arial';
                ctx.fillStyle = 'black';
                ctx.fillText('Game Over', canvas.width / 2 - 100, canvas.height / 2 - 20);
                ctx.font = '20px Arial';
                ctx.fillText('Your Score: ' + score, canvas.width / 2 - 40, canvas.height / 2 + 20);
                ctx.fillText('Press Space or Click to Play Again', canvas.width / 2 - 120, canvas.height / 2 + 60);
            } else {
                // Gravity
                player.y += player.velocityY;
                player.velocityY += 1;
                if (player.y >= canvas.height - player.height) {
                    player.y = canvas.height - player.height;
                    player.velocityY = 0;
                    player.jumping = false;
                }

                // Draw player
                drawPlayer();

                // Move obstacles
                for (const obstacle of obstacles) {
                    obstacle.x -= 5;
                }

                // Remove off-screen obstacles
                obstacles.forEach((obstacle, index) => {
                    if (obstacle.x + obstacle.width < 0) {
                        obstacles.splice(index, 1);
                        score += 1;
                    }
                });

                // Draw obstacles
                drawObstacles();

                // Collision detection
for (const obstacle of obstacles) {
    if (
        player.x < obstacle.x + obstacle.width &&
        player.x + player.width > obstacle.x &&
        player.y < obstacle.y + obstacle.height &&
        player.y + player.height > obstacle.y
    ) {
        // Collision with any obstacle, game over
        gameOver = true;
    }
}

                // Increase score
                ctx.font = '20px Arial';
                ctx.fillStyle = 'black';
                ctx.fillText('Score: ' + score, 10, 30);

                // Update obstacle spawn speed based on score
                updateObstacleSpeed();
            }

            requestAnimationFrame(update);
        }

        function jump() {
            if (!player.jumping && !gameOver) {
                player.velocityY = -15;
                player.jumping = true;
            } else if (gameOver) {
                // Restart the game when space or click is pressed after game over
                resetGame();
            }
        }

        document.addEventListener('keydown', function (event) {
            if (event.code === 'Space') {
                jump();
            }
        });

        canvas.addEventListener('click', function () {
            jump();
        });

        function resetGame() {
            player.y = canvas.height - 50;
            player.velocityY = 0;
            player.jumping = false;
            obstacles.length = 0;
            score = 0;
            gameOver = false;
            obstacleSpawnInterval = 2000; // Reset the obstacle spawn interval to the initial value
        }

        // Generate obstacles with the specified spawn interval
        setInterval(function () {
            if (!gameOver) {
                // Randomly select the type of obstacle (rock, tree, or bird)
                const obstacleType = Math.random() < 0.33 ? 'rock' : Math.random() < 0.66 ? 'tree' : 'bird';

                let obstacleHeight;
                let obstacleWidth;
                let obstacleY;

                if (obstacleType === 'bird') {
                    // Bird should spawn above the player's head with a fixed height and width
                    obstacleHeight = 20; // Set a fixed height for the bird
                    obstacleWidth = 70;  // Set the width of the bird to 70
                    obstacleY = (player.y - 30) - obstacleHeight; // Position the bird above the player's head
                } else if (obstacleType === 'rock') {
                    // Rock should have a fixed size of 20x20
                    obstacleHeight = 20;
                    obstacleWidth = 20;
                    obstacleY = canvas.height - obstacleHeight;
                } else {
                    // Tree should have a height of 60
                    obstacleHeight = 60;
                    obstacleWidth = 40;
                    obstacleY = canvas.height - obstacleHeight;
                }

                const obstacle = {
                    x: canvas.width,
                    y: obstacleY,
                    width: obstacleWidth,
                    height: obstacleHeight,
                    type: obstacleType,
                };

                obstacles.push(obstacle);
            }
        }, obstacleSpawnInterval);

        animatePlayer(); // Start the player image animation

        update();
    </script>
</body>
</html>
